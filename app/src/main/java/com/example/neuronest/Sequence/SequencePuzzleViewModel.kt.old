package com.example.neuronest.Sequence

import androidx.lifecycle.viewModelScope
import com.example.neuronest.profile.ProfileRepository
import com.example.neuronest.puzzlelevels.BasePuzzleViewModel
import com.example.neuronest.puzzlelevels.LevelRepository
import com.example.neuronest.sound.SoundManager
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class SequencePuzzleViewModel @Inject constructor(
    levelRepository: LevelRepository,
    private val profileRepository: ProfileRepository, soundManager: SoundManager
) : BasePuzzleViewModel(levelRepository, profileRepository, soundManager) {

    override val puzzleType = "Sequence"

    private val _uiState = MutableStateFlow(SequencePuzzleState())
    val uiState: StateFlow<SequencePuzzleState> = _uiState.asStateFlow()

    private val _isCorrect = MutableStateFlow<Boolean?>(null)
    val isCorrect: StateFlow<Boolean?> = _isCorrect.asStateFlow()

    private var puzzleStartTime: Long = 0
    override var hintsUsed: Int = 0

    init {
        problemsRequired = 5 // 5 sequence puzzles per level
    }

    override fun onLevelLoaded(level: Int) {
        generateNewPuzzle()
    }

    fun generateNewPuzzle() {
        viewModelScope.launch {
            val puzzle = SequenceGenerator.generatePuzzle()
            _uiState.value = SequencePuzzleState(
                sequence = puzzle.sequence,
                correctAnswer = puzzle.answer,
                feedback = ""
            )
            _isCorrect.value = null
            puzzleStartTime = System.currentTimeMillis()
            hintsUsed = 0
        }
    }

    fun checkAnswer(userAnswer: String) {
        val answer = userAnswer.toIntOrNull()
        val currentState = _uiState.value
        val timeTaken = System.currentTimeMillis() - puzzleStartTime

        if (answer == currentState.correctAnswer) {
            val points = calculateScore(timeTaken, hintsUsed)
            _score.value += points.toInt()

            viewModelScope.launch {
                profileRepository.updatePuzzleResult(
                    puzzleType = puzzleType,
                    difficulty = getDifficulty(_currentLevel.value),
                    wasSolved = true,
                    timeTakenMs = timeTaken,
                    hintsUsed = hintsUsed,
                    scoreEarned = points
                )
            }

            _uiState.value = currentState.copy(
                feedback = "Correct! +$points points"
            )
            _isCorrect.value = true

            onProblemSolved(timeTaken, hintsUsed)

            // Generate new puzzle if level not complete
            viewModelScope.launch {
                kotlinx.coroutines.delay(1500)
                if (!_isLevelComplete.value) {
                    generateNewPuzzle()
                }
            }
        } else if (answer == null) {
            _uiState.value = currentState.copy(
                userAnswer = "",
                feedback = "Please enter a valid number!"
            )
            _isCorrect.value = false
        } else {
            viewModelScope.launch {
                profileRepository.updatePuzzleResult(
                    puzzleType = puzzleType,
                    difficulty = getDifficulty(_currentLevel.value),
                    wasSolved = false,
                    timeTakenMs = timeTaken,
                    hintsUsed = hintsUsed,
                    scoreEarned = 0
                )
            }

            _uiState.value = currentState.copy(
                feedback = "Wrong! Try again",
                userAnswer = userAnswer
            )
            _isCorrect.value = false
        }
    }

    fun skipPuzzle() {
        _uiState.value = _uiState.value.copy(
            feedback = "Skipped! Answer was ${_uiState.value.correctAnswer}",
            userAnswer = ""
        )
        _isCorrect.value = null
        
        viewModelScope.launch {
            kotlinx.coroutines.delay(1500)
            if (!_isLevelComplete.value) {
                generateNewPuzzle()
            }
        }
    }

    fun updateUserAnswer(answer: String) {
        _uiState.value = _uiState.value.copy(userAnswer = answer)
    }

    fun resetIsCorrectFlag() {
        _isCorrect.value = null
    }

    fun useHint() {
        hintsUsed++
        val hintMessage = when (hintsUsed) {
            1 -> "Hint: Look for arithmetic patterns like addition or multiplication"
            2 -> "Hint: Check if there's a common difference or ratio between numbers"
            3 -> "Hint: The pattern might involve alternating operations"
            else -> "No more hints available"
        }
        _uiState.value = _uiState.value.copy(feedback = hintMessage)
    }

    private fun calculateScore(timeTaken: Long, hintsUsed: Int): Long {
        val baseScore = 100L
        val timeBonus = maxOf(0, (30000 - timeTaken) / 100)
        val hintPenalty = hintsUsed * 20
        return baseScore + timeBonus - hintPenalty
    }

    private fun getDifficulty(level: Int): String {
        return when {
            level <= 100 -> "Easy"
            level <= 300 -> "Medium"
            else -> "Hard"
        }
    }

    override fun resetLevelState() {
        super.resetLevelState()
        generateNewPuzzle()
    }
}

data class SequencePuzzleState(
    val sequence: List<Int> = emptyList(),
    val correctAnswer: Int = 0,
    val userAnswer: String = "",
    val feedback: String = ""
)