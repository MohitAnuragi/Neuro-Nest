package com.example.neuronest.futoshiki

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.neuronest.profile.ProfileRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class FutoshikiViewModel @Inject constructor(
    private val profileRepository: ProfileRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(FutoshikiUiState())
    val uiState: StateFlow<FutoshikiUiState> = _uiState.asStateFlow()
    private val generator = FutoshikiGenerator()

    // Profile tracking variables
    private var puzzleStartTime: Long = 0
    private var hintsUsed: Int = 0
    private var movesCount: Int = 0

    init {
        loadNewPuzzle("easy")
        startPuzzleTimer()
    }

    private fun startPuzzleTimer() {
        puzzleStartTime = System.currentTimeMillis()
        hintsUsed = 0
        movesCount = 0
    }

    fun loadNewPuzzle(difficulty: String) {
        val puzzleData = when (difficulty) {
            "easy" -> generator.generatePuzzle(4, 8, 6)
            "medium" -> generator.generatePuzzle(5, 10, 10)
            "hard" -> generator.generatePuzzle(6, 12, 15)
            else -> generator.generatePuzzle(4, 8, 6)
        }
        val newGrid = puzzleData.initialGrid.map { it.toMutableList() }.map { it.toList() }
        _uiState.update { currentState ->
            currentState.copy(
                difficulty = difficulty,
                grid = newGrid,
                initialGrid = puzzleData.initialGrid,
                constraints = puzzleData.constraints,
                size = puzzleData.size,
                message = "New ${difficulty.capitalize()} puzzle loaded!",
                isSolved = false,
                selectedCell = null
            )
        }
        startPuzzleTimer()
    }

    /**
     * Handles the user entering text into a grid cell.
     */
    fun onCellValueChange(row: Int, col: Int, value: String) {
        if (uiState.value.isSolved || uiState.value.initialGrid[row][col] != 0) {
            return
        }

        // Validate input: must be a single digit and within the puzzle's range.
        val number = value.toIntOrNull()
        if (value.isNotEmpty() && (number == null || number !in 1..uiState.value.size)) {
            _uiState.update { it.copy(message = "Invalid input! Please enter a digit from 1 to ${uiState.value.size}.") }
            return
        }

        // Create a temporary grid with the new number
        val newGrid = uiState.value.grid.map { it.toMutableList() }.toMutableList()
        newGrid[row][col] = number ?: 0

        // Check if the temporary grid is valid
        if (isValid(newGrid.map { it.toList() }, uiState.value.constraints)) {
            movesCount++
            val message = if (number == null) "Cell cleared!" else "Valid move!"
            _uiState.update { it.copy(grid = newGrid.map { it.toList() }, message = message) }

            if (isSolved(newGrid.map { it.toList() })) {
                val timeTaken = System.currentTimeMillis() - puzzleStartTime
                val scoreEarned = calculateScore(timeTaken, hintsUsed, movesCount, uiState.value.difficulty)

                // Update profile with successful solution
                viewModelScope.launch {
                    profileRepository.updatePuzzleResult(
                        puzzleType = "Futoshiki",
                        difficulty = uiState.value.difficulty,
                        wasSolved = true,
                        timeTakenMs = timeTaken,
                        hintsUsed = hintsUsed,
                        scoreEarned = scoreEarned
                    )
                }

                _uiState.update {
                    it.copy(
                        isSolved = true,
                        message = "Congratulations! You solved the puzzle! +$scoreEarned points"
                    )
                }
            }
        } else {
            // If the move is invalid, just update the message. The grid state remains unchanged.
            _uiState.update { it.copy(message = "Invalid move! Please try a different number.") }
        }
    }

    /**
     * Selects a cell for input.
     */
    fun selectCell(row: Int, col: Int) {
        if (uiState.value.isSolved || uiState.value.initialGrid[row][col] != 0) {
            return
        }
        _uiState.update { it.copy(selectedCell = Pair(row, col)) }
    }

    /**
     * Clears the selected cell.
     */
    fun clearSelectedCell() {
        _uiState.update { it.copy(selectedCell = null) }
    }

    /**
     * Provides a hint to the user.
     */
    fun useHint() {
        hintsUsed++
        // You can implement specific hint logic here
        _uiState.update { it.copy(message = "Hint used! ${3 - hintsUsed} hints remaining") }
    }

    /**
     * Skips the current puzzle.
     */
    fun skipPuzzle() {
        val timeTaken = System.currentTimeMillis() - puzzleStartTime

        // Track skipped puzzle in profile
        viewModelScope.launch {
            profileRepository.updatePuzzleResult(
                puzzleType = "Futoshiki",
                difficulty = uiState.value.difficulty,
                wasSolved = false,
                timeTakenMs = timeTaken,
                hintsUsed = hintsUsed,
                scoreEarned = 0
            )
        }

        _uiState.update { it.copy(message = "Puzzle skipped! Loading new puzzle...") }
        loadNewPuzzle(uiState.value.difficulty)
    }

    /**
     * Validates the current state of the grid.
     */
    private fun isValid(grid: List<List<Int>>, constraints: List<Constraint>): Boolean {
        val size = grid.size

        // Check rows for duplicates
        for (i in 0 until size) {
            val rowValues = mutableSetOf<Int>()
            for (j in 0 until size) {
                val value = grid[i][j]
                if (value != 0) {
                    if (rowValues.contains(value)) return false
                    rowValues.add(value)
                }
            }
        }

        // Check columns for duplicates
        for (j in 0 until size) {
            val colValues = mutableSetOf<Int>()
            for (i in 0 until size) {
                val value = grid[i][j]
                if (value != 0) {
                    if (colValues.contains(value)) return false
                    colValues.add(value)
                }
            }
        }

        // Check constraints
        for (c in constraints) {
            val cell1 = grid[c.row1][c.col1]
            val cell2 = when (c.direction) {
                0 -> grid[c.row1][c.col1 + 1] // Horizontal constraint
                else -> grid[c.row1 + 1][c.col1] // Vertical constraint
            }

            // Only validate if both cells have values
            if (cell1 != 0 && cell2 != 0) {
                if (c.type == '>' && cell1 <= cell2) return false
                if (c.type == '<' && cell1 >= cell2) return false
            }
        }

        return true
    }

    private fun isSolved(grid: List<List<Int>>): Boolean {
        val size = grid.size
        for (i in 0 until size) {
            for (j in 0 until size) {
                if (grid[i][j] == 0) return false
            }
        }
        return isValid(grid, uiState.value.constraints)
    }

    private fun calculateScore(timeTaken: Long, hintsUsed: Int, movesCount: Int, difficulty: String): Long {
        val baseScore = when (difficulty) {
            "easy" -> 150
            "medium" -> 250
            "hard" -> 400
            else -> 150
        }

        val timeBonus = when (difficulty) {
            "easy" -> maxOf(0, (120000 - timeTaken) / 200) // 2 minutes max
            "medium" -> maxOf(0, (180000 - timeTaken) / 250) // 3 minutes max
            "hard" -> maxOf(0, (240000 - timeTaken) / 300) // 4 minutes max
            else -> 0
        }

        val hintPenalty = hintsUsed * 40
        val moveBonus = when (difficulty) {
            "easy" -> maxOf(0, (30 - movesCount) * 5) // Fewer moves = better
            "medium" -> maxOf(0, (40 - movesCount) * 6)
            "hard" -> maxOf(0, (50 - movesCount) * 7)
            else -> 0
        }

        return baseScore + timeBonus + moveBonus - hintPenalty
    }
}

data class FutoshikiUiState(
    val grid: List<List<Int>> = emptyList(),
    val initialGrid: List<List<Int>> = emptyList(),
    val constraints: List<Constraint> = emptyList(),
    val size: Int = 0,
    val message: String = "Tap on a cell and type a number to begin!",
    val isSolved: Boolean = false,
    val difficulty: String = "easy",
    val selectedCell: Pair<Int, Int>? = null
)